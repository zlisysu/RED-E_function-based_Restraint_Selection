from .gen_plumed import Gen_plumed_input
from .restraint_aly_tools_openmm_ver import ALL_Restrain_Data, Restrain_Data, RED_FIT, RestraintParam
from .Selection_by_lig_shape import Frame, Residue, Protein, Ligand, Atom, get_res_idx_within_one_residue, ligand_shape_based_sel
from .Selection_by_HB_pair import Sel_rest_atm_hb_pair_based, Hb_pair_group, Speci_restr
from .Selection_by_HB_mainchain import Sel_rest_atm_hb_mainchain_based, Hb_pair_group_mainchain, Speci_restr_mainchain
import mdtraj as md
import parmed as pmd
import numpy as np
import pandas as pd
class Res_atom_select():
    def __init__(self, xyz_file, top_file, plumed_input_file, plumed_output_file, plumed_cal_freq):
        '''Initializing
        
        Parameters
        ----------
        xyz_file: str
            Name of the coordinate file. Supporting: *.gro, *.rst7, *.pdb
        top_file: str
            Name of the topology file. Supporting: *.prmtop
        plumed_input_file: str
            Name of the plumed input file, which will be generated by this function. 
        plumed_output_file: str
            Name of the plumed output file, which will be generated by the following molecular dynamic simulation.
        plumed_cal_freq: int
            Specifies the frequence with which the collective variables of interest should be output.
        '''
        xyz_suffix = xyz_file.strip('.')[-1]
        if xyz_suffix == 'gro':
            self.xyz_file = xyz_file
            self.traj = md.load(self.xyz_file, )
        else:
            self.xyz_file = xyz_file
            self.top_file = top_file
            self.traj = md.load(self.xyz_file, top=self.top_file)
        ###### modify for receive a openmm system object, not finished yet ######
        # self.traj = system_container
        self.parm = pmd.load_file(self.top_file,  xyz=self.xyz_file)
        # self.parm = parm

        self.plumed_input_file = plumed_input_file
        self.plumed_output_file = plumed_output_file
        self.plumed_cal_freq = plumed_cal_freq

    def get_restr_plumed_input(self, lig_resi_name='MOL', iflog=False):
        '''Generate candidate restraint atom groups based on three strategies, and generate corresponding plumed input files. 
        
        Reference
        ----------
        doi:not published yet 

        Parameters
        ----------
        lig_resi_name: str
            The residue name of the ligand, default: 'MOL'.
        iflog: bool
            Whether to record the constraint atom groups selected by each strategy, and store them in three files: based_lig_shape, based_HB_pair, and based_HB_mainchain. And save all the constraint atom groups after deduplication into the all_lst file. Default: False.

        Example
        ----------
        >>> from utils.restraint_aly_tools_openmm_ver import *
        >>> test_ = Res_atom_select('protein.rst7', 'protein.prmtop', 'plumed.dat', 'Colvar', 100)
        >>> test_.get_restr_plumed_input('MOL', True)
        '''
        # First strategy
        lst_z = ligand_shape_based_sel(self.traj, lig_resi_name)
        self.based_lig_shape_res_atom = lst_z
        if iflog:
            grp_num1=len(lst_z)
            print(f"Selected by first_stategy: {lst_z} with number of {grp_num1}")
            lst_z_file=open('based_lig_shape', 'w+')
            print(str(lst_z), file=lst_z_file)
            lst_z_file.close()
        # Second strategy
        a = Sel_rest_atm_hb_pair_based(self.traj, self.parm, lig_resi_name)
        lst_a = a.get_final_res_lst()
        self.based_HB_pair_res_atom = lst_a
        if iflog:
            grp_num2=len(lst_a)
            print(f"Selected by second_stategy: {lst_a} with number of {grp_num2}")
            lst_a_file = open('based_HB_pair', 'w+')
            print(str(lst_a), file=lst_a_file)
            lst_a_file.close()
        # Third strategy
        b = Sel_rest_atm_hb_mainchain_based(self.traj, self.parm, lig_resi_name)
        lst_b = b.get_final_res_lst()
        self.based_HB_mainchain_res_atom = lst_b
        if iflog:
            grp_num3=len(lst_b)
            print(f"Selected by third_stategy: {lst_b} with number of {grp_num3}")
            lst_b_file = open('based_HB_mainchain', 'w+')
            print(lst_b, file=lst_b_file)
            lst_b_file.close()
        six_atoms=[]
        six_atoms+=lst_z
        six_atoms+=lst_a
        six_atoms+=lst_b
        #deduplication
        six_atoms = [list(i) for i in set(tuple(h) for h in six_atoms)]
        if iflog:
            grp_num4=len(six_atoms)
            print(f"After deduplication, Selected by three_stategy: {six_atoms} with number of {grp_num4}")
            lst_all_file = open('all_lst', 'w+')
            print(str(six_atoms), file=lst_all_file)
            lst_all_file.close()
        self.muti_six_atm_lst = six_atoms
        gen_ = Gen_plumed_input(six_atoms)
        gen_.gen_BoreschLike_measure(self.plumed_input_file, self.plumed_output_file, self.plumed_cal_freq)

    def gen_mbarlike_resene_csv(self, arry, lambdas, nsteps, timestep=4, sample_interval=100, output_csv_name='state_s0.csv'):
        '''
        
        Parameters
        ----------
        arry: np.array, shape(N,)
            The numpy array storing the deltaU values **with unit of k_{B}T**, which were calculated by the potential energy of the fully restraint state minus that of the free state.
        lambdas: dict 
            This dict is used to specify the lambda scheme.
            Like:  lambdas_group_12stp={
                                        'lambda_restraints'     : [0.00, 0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1.00,],
                                        'lambda_electrostatics' : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,],
                                        'lambda_sterics'        : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,]
                                        }
        nsteps: int
            The simulation steps.
        timestep: float, unit: femtoseconds, like: 4 
            The simulation update timestep.
        sample_interval: int, default: 100
            The interval of the sampling.
        output_csv_name: str, default: 'state_s0.csv'
            The name of the output csv file, which logs the potential energy values of the first state and the second state. (Other state's potential energy values are zero, may be questionable) 
        
        Generate 
        ----------
            The output_csv_file of first_simulation_df(which logs the potential energy values of the first state and the second state. (Other state's potential energy values are zero, may be questionable))
        '''
        all_should_be_sample_num = int(nsteps/sample_interval)
        # print(f'nstep:{nsteps}, sample_interval:{sample_interval}, all_should_be_sample_num:{all_should_be_sample_num}')
        pass_arry_sample_num = arry.shape[0]
        supp_zero_ary = np.zeros(all_should_be_sample_num-pass_arry_sample_num,)
        all_data_ary = np.concatenate([supp_zero_ary, arry])
        all_nan_ary = np.empty(all_should_be_sample_num,)
        all_nan_ary[:]=np.nan
        lambdas_df = self.convert_openmm_lambdas2gmx_lambdas(lambdas)
        simulation_lambda_values = tuple(lambdas_df.iloc[0,:])
        simulation_lambda_types = list(lambdas_df.columns)
        simulation_lambda_types.insert(0, 'times(ps)')
        times_lambda_tuples = [(i*sample_interval*timestep/1000,)+tuple(simulation_lambda_values)  for i in range(0, all_should_be_sample_num)]
        muti_idx = pd.MultiIndex.from_tuples(times_lambda_tuples, names=simulation_lambda_types)
        columns_ = [tuple(i[1]) for i in lambdas_df.iterrows()]
        zero_shape = np.zeros((all_should_be_sample_num, len(columns_)))
        first_simulation_df = pd.DataFrame(zero_shape, columns=columns_, index=muti_idx)

        first_lambda_ele = lambdas_df['lambda_electrostatics'][0]
        first_lambda_vdw = lambdas_df['lambda_sterics'][0]
        for i in range(0, len(lambdas_df['lambda_restraints'])):
            lambda_res = lambdas_df['lambda_restraints'][i]
            lambda_ele = lambdas_df['lambda_electrostatics'][i]
            lambda_vdw = lambdas_df['lambda_sterics'][i]
            if lambda_ele == first_lambda_ele and lambda_vdw == first_lambda_vdw:
                column_data = lambda_res * all_data_ary
            else:
                column_data = all_nan_ary
            _column = (lambda_res, lambda_ele, lambda_vdw) 
            first_simulation_df[_column] = column_data
        first_simulation_df.to_csv(output_csv_name, sep="|")


    def convert_openmm_lambdas2gmx_lambdas(self, lambdas):
        '''convert the openmm style lambdas to the gmx style lambdas
        Parameters
        ----------
        lambdas: dict 
            This dict is used to specify the lambda scheme.
            Like:  lambdas_group_12stp={
                                        'lambda_restraints'     : [0.00, 0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1.00,],
                                        'lambda_electrostatics' : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,],
                                        'lambda_sterics'        : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,]
                                        }

        Return 
        ----------
        lambdas_df: pandas.DataFrame
            The dataframe that with columns of ['lambda_restraints', 'lambda_electrostatics', 'lambda_sterics'], and index of range(0, len(lambdas['lambda_restraints'])), and the lambda value of 1.00 indicate that the electrostatics and vdW term of the alchemical region was completely annihilated. 
        '''
        lambdas_df = pd.DataFrame.from_dict(lambdas)
        lambdas_df['lambda_electrostatics'] = [np.around(1-i, decimals=2) for i in lambdas_df['lambda_electrostatics']]
        lambdas_df['lambda_sterics'] = [np.around(1-i, decimals=2) for i in lambdas_df['lambda_sterics']]
        return lambdas_df

    def aly_traj_get_best_rest(self, lambda_group, fake_state_xml, first_state_csv, nsteps, timestep):
        '''After preliminary MD, analyze the output file of plumed, and obtain the optimal constraint atom group and corresponding constraint parameters based on the RED formula. And output the internal energy difference between the free state and the next constrained state and return a class includes all the information needed for the harmonic restints addition during the alchemical transformation MD.

        Parameters
        ----------
        lambda_group: dict
            This dict is used to specify the lambda scheme.
            Like:  lambdas_group_12stp={
                                        'lambda_restraints'     : [0.00, 0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1.00,],
                                        'lambda_electrostatics' : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,],
                                        'lambda_sterics'        : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,]
                                        }
        fake_state_xml: str, default: 'state_s0.xml' or None
            The name of fake state xml file that is used to skip the alchemical simulation of the free state (that is the first lambda)
        nsteps: int
            The simulation steps.
        timestep: float, unit: femtoseconds, like: 4 
            The simulation update timestep.

        Return 
        ----------
        res_parm_format: <class 'RestraintParam'>
            A class includes all the information needed for the harmonic restaints addition during the alchemical transformation MD.

        Example
        ----------
        >>> from utils.restraint_aly_tools_openmm_ver import *
        >>> test_ = Res_atom_select('protein.rst7', 'protein.prmtop', 'plumed.dat', 'Colvar', 100)
        >>> test_.get_restr_plumed_input('MOL', True)
        After preliminary MD:
        >>> lambdas_group_12stp={
                                'lambda_restraints'     : [0.00, 0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1.00,],
                                'lambda_electrostatics' : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,],
                                'lambda_sterics'        : [1.00, 1.00,  1.00, 1.00,  1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,]
                                }
        >>> res_parm = test_.aly_traj_get_best_rest(lambdas_group_12stp, 'state_s0.xml')
        '''
        all_data_path = self.plumed_output_file
        res = ALL_Restrain_Data(all_data_path=all_data_path, muti_six_atm_lst=self.muti_six_atm_lst, fraction=0.75)
        self.All_res_obj = res
        res.process_data()
        res.generate_csv(csv_name="res_data_ori.csv", lst=res.restrain_data_list)
        res.generate_csv(csv_name="res_databyfopt.csv", lst=res.sort_result())

        count = -1
        for i in res.sort_result():
            count+=1
            if count < 20:
                print('The serial number is {}.'.format(str(count+1)))
                if i.restrain_group in self.based_lig_shape_res_atom:
                    print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by first strategy.')
                    print('The cost function value is '+str(i.fopt))
                elif i.restrain_group in self.based_HB_pair_res_atom:
                    print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by second strategy.')
                    print('The cost function value is '+str(i.fopt))
                elif i.restrain_group in self.based_HB_mainchain_res_atom:
                    print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by third strategy.')
                    print('The cost function value is '+str(i.fopt))
        best=res.get_best_result()
        res_parm = best.get_res_parm_4_openmm()
        res_parm_format = RestraintParam(rec_atoms=res_parm.rec_atoms,lig_atoms=res_parm.lig_atoms,r=res_parm.r,theta1=res_parm.theta1,theta2=res_parm.theta2,phi1=res_parm.phi1,phi2=res_parm.phi2,phi3=res_parm.phi3)
        
        output_dU = best.delta_u
        self.gen_mbarlike_resene_csv(output_dU, lambda_group, nsteps, timestep, self.plumed_cal_freq, first_state_csv)

        res.generate_csv(csv_name="res_databystd.csv", lst=res.res_list_4_std_sort)
        best.draw_figure('best.png')
        with open('restr.txt', 'w') as restr_file:
            restr_file.write(best.echo_rest_txt('openmm'))

        if fake_state_xml:
            with open(fake_state_xml, 'w') as fake_state_xml_file:
                fake_state_xml_file.write('This is a fake first lambda state xml file.')
        return res_parm_format

if __name__ == '__main__':
    #amber
    test_ = Res_atom_select('protein.rst7', 'protein.prmtop', 'plumed.dat', 'Colvar', 100)
    #gromacs
    #test_ = Res_atom_select('complex.gro', None, 'plumed.dat', 'Colvar', 100)        
    test_.get_restr_plumed_input('MOL', True)

    ##after preliminary MD, do this
    # res_parm = test_.aly_traj_get_best_rest()
