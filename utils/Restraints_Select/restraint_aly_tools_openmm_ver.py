from scipy import optimize
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import sys 
import numpy as np
import timeit
import pandas as pd
import os
from scipy.optimize import minimize
from .gen_plumed import Gen_plumed_input

class RED_FIT():
    '''Restraint Energy Distribution(RED) function based fitting for the delta_U probability distribution.

    '''
    def __init__(self, d_u, bins=100):
        '''Initializing
        
        Parameters
        ----------
        d_u: array_like
            A series of delta_U values ((U_restrained - U_free) or (U_restrained - U_free)) with unit of kbT.
        bins: int, default: 100
            The bins used to generate the histogram of d_u.
        
        Key properties
        ----------
        self.u_l: np.array
            A series of delta_U values ((U_restrained - U_free) or (U_restrained - U_free)) with unit of kbT. 
            Its initial value was as same as the d_u. Then self.u_l will be filtered and reserve the delta_U, which is smaller than the five times of the theoretical mean of the delta_U (In RED function, the mean of delta_U is equal to the 2 times of the delta_U values with the highest probability.)
        self.pu_arr_orig: array_like
            The normalized probability of the original d_u generated by the np.histogram(self.u_l, bins=bins, density=True) (before filteration of self.u_l )
        self.xu_orig: np.array
            It have the same shape of self.pu_arr_orig, in which everyone is the midpoint value of each bin.
        self.pu_arr: np.array
             The normalized probability of the filtered d_u generated by the np.histogram(self.u_l, bins=bins, density=True) (after filteration of self.u_l )
        self.xu_arr: np.array
            It have the same shape of self.pu_arr, in which everyone is the midpoint value of each bin.
        self.u_mean: float
            The actual mean value of the filtered self.u_l
        self.u_std: float
            The actual standard deviation of the filtered self.u_l
        '''
        self.u_l=np.array(d_u)
        self.u_mean = np.mean(self.u_l)
        self.pu_arr_orig,xu_arr_add1_orig = np.histogram(self.u_l,bins=bins,density=True)
        xu_orig = []
        for i in range(len(xu_arr_add1_orig)-1):
            xu_orig.append((xu_arr_add1_orig[i]+xu_arr_add1_orig[i+1])/2)
        self.xu_arr_orig = np.array(xu_orig)        
        y_max = self.pu_arr_orig.max()
        #print (np.where(self.pu_arr_orig == y_max))
        #print (np.where(self.pu_arr_orig == y_max)[0])
        index = int(np.where(self.pu_arr_orig == y_max)[0][0])
        #print (index)
        x_max = self.xu_arr_orig[index] #the point with the highest y value
        
        mean = 2 * x_max # can be derived based on the equation b^2*exp(-bx)*x
        # self.u_l = self.u_l[self.u_l< (6*mean)]
        self.b_guess_by_max = 1/x_max
        
        self.pu_arr,xu_arr_add1 = np.histogram(self.u_l,bins=bins,density=True)
        xu = []
        for i in range(len(xu_arr_add1)-1):
            xu.append((xu_arr_add1[i]+xu_arr_add1[i+1])/2)

        self.xu_arr = np.array(xu)
        self.b_guess_by_mean = 2/self.u_mean
        # self.pu_arr = self.pu_arr/self.b_guess_by_max
        # self.xu_arr = self.xu_arr/self.b_guess_by_max
        self.pu_arr = self.pu_arr[self.xu_arr< (5*mean)]
        self.xu_arr = self.xu_arr[self.xu_arr< (5*mean)]

        where_are_inf = np.isinf(self.u_l)
        if self.u_mean > 0:
            self.u_l[where_are_inf] = 999.0
        else:
            self.u_l[where_are_inf] = -999.0

        self.u_std = np.std(self.u_l)

        self.sampled_u_mean = np.sum(self.pu_arr * self.xu_arr) / np.sum(self.pu_arr)
        self.sampled_u_std  = np.sqrt(np.sum(self.pu_arr * (self.xu_arr - self.sampled_u_mean)**2) / np.sum(self.pu_arr))
        self.sampled_u_value_y_max  = x_max
      
        
    def residues_common(self,p,f,y,x):
        '''Calculate the sum of squares of the difference between the model predicted value and the actual sampled value.

        Parameters
        ----------
        p: np.array or float
            The parameter that may be optimized in the function.
        f: function
            The function receive p and x to get the predicted y.
        y: np.array
            The acutal sampled values.
        x: np.array
            The independent variable of the function.
        
        Return
        ----------
        np.sum((y-f(p,x))**2)
        '''
        return np.sum((y-f(p,x))**2)

    def gm4rd(self,p,x):
        '''Restraint energy distribution (RED) function. $P\left(\Delta U_{i+1, i}\right)=b^{2} \exp \left(-b \Delta U_{i+1, i}\right) \cdot\left(\Delta U_{i+1, i}\right)$
        RED function's distribution property: U_mean = 2/b; U_max = 1/b; U_std = 2^(1/2)/b
                
        Parameters
        ----------
        p: np.array
            The parameter that may be optimized in the function, which only contain the b1.
        x: np.array
            The independent variable of the function. (In RED function, they are series of delta_U)
 
        Return
        ----------
        (b1**2) * abs(x) * np.exp(-b1 * abs(x))
        '''
        b1 = p[0]
        #return  np.exp(b1-a1) * x**2 * np.exp(-b1 * x - c1 * x**10)
        return (b1**2) * abs(x) * np.exp(-b1 * abs(x) )  #b1**2 term is for normalization                                           
                        
    def residues_rd(self,p,f,y,x):
        '''
        Not finished
        '''
        # return np.sum(((y-f(p,x))**2)*np.exp(y))# To make the large y have great weight when optimizing cost
        # return np.sum(((y-f(p,x))*self.u_mean*self.u_mean)**2)# To plus u_mean twice for f(p,x)=4*abs(x)*np.exp(-b * abs(x)) because u_mean = 2/b
        return np.sum(((y-f(p,x))*self.u_mean/2)**2)# The larger u_mean will lead to the larger u_std since U_mean = 2/b and U_std = 2^(1/2)/b. For getting the distribution with small u_mean(u_std) when ranking.
        # return np.sum(((y-f(p,x))*((self.u_mean/2)**2)*np.exp((2/self.u_mean)*x))**2)
        # return np.sum(((y-f(p,x))*((self.u_mean/2)**2)/np.exp(-1))**2)
        # return np.sum(((y-f(p,x*self.u_mean/2))*self.u_mean/2)**2)
        # return  np.sum(((y-f(p,x))**2)/x)
        # return np.sum((y-f(p,x))**2)


    def func_fit(self,func,p0,residues,add00=False):
        '''Relatively common curve fitting method.

        Parameters
        ----------
        func: function
            The function receive p and x to get the predicted y, as the second parameter of resides.
        p0: np.array or float
            The parameter that may be optimized in the function.
        residues: function
            The cost function which receive the optimized parameter, the potential functions that describe probability distributions, the distribution x and y for fitting. 
        add00: bool
            Judge if the do the edge smoothing.
        
        Return
        ----------
        plsq_full: tuple
            The tuple contains 5 elements. We need the first and second element. The first element is a np.array containing the parameter that was optimized in the function. The second element is the final cost function's value. 
        '''
        fit_xu_arr=self.xu_arr
        fit_pu_arr=self.pu_arr
        
        if add00:
            fit_xu_arr = np.append(fit_xu_arr,0.0)
            fit_pu_arr = np.append(fit_pu_arr,0.0)
            if self.u_mean > 0:            
                maxval = fit_xu_arr.max()
                for i in range(5):
                    fit_xu_arr = np.append(fit_xu_arr,maxval+0.5*(i+1))
                    fit_pu_arr = np.append(fit_pu_arr,0.0)
            else:
                minval = fit_xu_arr.min()
                for i in range(5):
                    fit_xu_arr = np.append(fit_xu_arr,minval-0.5*(i+1))
                    fit_pu_arr = np.append(fit_pu_arr,0.0)
        plsq_full = optimize.fmin(residues, p0, args=(func, fit_pu_arr, fit_xu_arr),maxiter=100000, full_output=True)
        # plsq_full = optimize.minimize(residues, p0, args=(func, fit_pu_arr, fit_xu_arr),maxiter=100000, full_output=True)
        return plsq_full


    def rd_fit(self):
        '''Restraint energy distribution fit. We derived the relationship between the mean delta_U and b1 based on the RED function, which is 
$\begin{aligned}
\langle\Delta U\rangle &=\int_{0}^{\infty} \Delta U \cdot P(\Delta U) d \Delta U \\
&=\int_{0}^{\infty} b^{2} \cdot \Delta U^{2} \cdot e^{-b \Delta U} d \Delta U \\
&=\frac{2}{b}
\end{aligned}$ 
For the initial guess value b1 in the RED function, we used the value of 2/<delta_U>.

        Generated or update properties
        ----------
        self.x: np.array
            10000 points between 0 and the maximum value of self.u_l (when the mean value of self.u_l is greater than 0), or 10000 points between the minimum value of self.u_l and 0 (when the mean value of self.u_l is less than 0)
        self.fitted_y: np.array
            A series of predicted probability values obtained by substituting self.x into the RED function.
        self.fitted_u: np.array
            Based on the probability distribution generated by self.fitted_y and self.x resampling, each bin value in self.x is repeated 1000 times according to the corresponding self.fitted_y.
        
        Return 
        ----------
        fopt: float
            The cost value of the RED function fitting.
        '''
        b1=2/self.u_mean
        p0=np.array([b1,])
        plsq_collect=self.func_fit(self.gm4rd,p0,self.residues_rd,add00=True)
        print('plsq_collect:')
        print(plsq_collect)
        # plsq_collect=self.func_fit(self.gm4rd,p0,self.residues_rd,add00=True)
        plsq=plsq_collect[0]
        fopt=plsq_collect[1]

        self.fitted_b = plsq_collect[0][0]
        self.theo_u_mean = 2/self.fitted_b 
        self.theo_u_value_y_max = 1/self.fitted_b
        self.theo_u_std  = 2**(0.5)/self.fitted_b
        if self.u_mean > 0:
            self.x = np.linspace(0, 1.0*self.u_l.max(),10000)
        else:
            self.x = np.linspace(1.0*self.u_l.min(),0, 10000)
        self.fitted_y = self.gm4rd(plsq,self.x)  
        # self.fitted_y = self.gm4rd(plsq,self.x*self.u_mean/2)*self.u_mean/2 
        self.fitted_u=[]
        for i in range(len(self.x)):
            self.fitted_u += [self.x[i] for j in range(int(round(self.fitted_y[i]*1000.0)))]
        self.fitted_u=np.array(self.fitted_u)
        
        return fopt
        
    def show_fit(self,pngfile,show_ori=True):
        '''Show the scatter points used for the fit, all the original scatter points (optional) and the fitted curve(RED function).

        Parameters
        ---------- 
        pngfile: str
            The name of the output png file.
        show_ori: bool
            If show all the original scatter points.       
        '''
        plt.clf()
        plt.figure(figsize=(16.2,12))
        #plt.title("Fitted probability distribution", fontsize=40) 
        #plt.xlabel("delta_U/${k_B}$T", fontsize=40) 
        #plt.ylabel("Probability density", fontsize=40) 
        plt.tick_params(labelsize=33, width=6.0, length=8.0)
        ax=plt.gca()
        ax.spines['bottom'].set_linewidth(4)
        ax.spines['left'].set_linewidth(4)
        ax.spines['right'].set_linewidth(4)
        ax.spines['top'].set_linewidth(4)
        print(f'best fit: b_guess_by_mean: {self.b_guess_by_mean}, b_guess_by_max: {self.b_guess_by_max}, fitted_b: {self.fitted_b}')
        plt.plot(self.xu_arr,self.pu_arr,"o", color = "green", markersize=10)
        if show_ori:
            plt.plot(self.xu_arr_orig, self.pu_arr_orig, "o", color = "gray", markersize=10)
        else:
            pass
        plt.plot(self.x, self.fitted_y, color='red', linewidth=5)

        if not pngfile:
            plt.show()
        else:
            plt.savefig(pngfile, transparent=True)

    def show_original_data(self):
        '''Show the original scatter points plot
        '''
        plt.clf()
        plt.figure(figsize=(16.2,12))
        plt.tick_params(labelsize=33, width=6.0, length=8.0)
        ax=plt.gca()
        ax.spines['bottom'].set_linewidth(4)
        ax.spines['left'].set_linewidth(4)
        ax.spines['right'].set_linewidth(4)
        ax.spines['top'].set_linewidth(4)
        plt.plot(self.xu_arr,self.pu_arr,"o")  
        plt.show()


class Restrain_Data():
    def __init__(self, restrain_group, six_para_df, fraction, ):
        '''Initializing
        
        Parameters
        ----------
        restrain_group: list
            A list containing the index of the six atoms needed for restraint, 
            like [lig1, lig2, lig3, rec1, rec2, rec3], all the lig* or rec* are atom number (starting from 1) and int datatype.  
        fraction: float
            The float for assigning what percentage of the data used in the analysis.
        six_para_df: pd.DataFrame
            The DataFrame with shape of (N, 6), in which N is the number of frames.
            six_para_df.iloc[:,0] is the column that stores all the data of r(DISTANCE ATOMS=lig1,rec1)
            six_para_df.iloc[:,1] is the column that stores all the data of thetaA(ANGLE ATOMS=lig1,rec1,rec2)
            six_para_df.iloc[:,2] is the column that stores all the data of thetaB(ANGLE ATOMS=lig2,lig1,rec1)
            six_para_df.iloc[:,3] is the column that stores all the data of phiA(TORSION ATOMS=rec3,rec2,rec1,lig1)
            six_para_df.iloc[:,4] is the column that stores all the data of phiB(TORSION ATOMS=rec2,rec1,lig1,lig2)
            six_para_df.iloc[:,5] is the column that stores all the data of phiC(TORSION ATOMS=rec1,lig1,lig2,lig3)
            
        Key properties
        ----------
        self.ene_list: np.array([])
            The np.array with shape of (N,), in which N is the number of frames after applying fraction, whose unit is kJ*mol^-1.
        self.fopt: float or None
            The initial value is None, and will be updated after Restraint Energy Distribution (RED) fitting,
            which is the cost of the fitting.
        ''' 
        self.restrain_group = restrain_group
        self.six_para_df = six_para_df
        self.six_para_df.columns = ['r(DISTANCE ATOMS=lig1,rec1)', 'thetaA(ANGLE ATOMS=lig1,rec1,rec2)', 'thetaB(ANGLE ATOMS=lig2,lig1,rec1)', 'phiA(TORSION ATOMS=rec3,rec2,rec1,lig1)', 'phiB(TORSION ATOMS=rec2,rec1,lig1,lig2)', 'phiC(TORSION ATOMS=rec1,lig1,lig2,lig3)']
        self.fraction = fraction
        
        self.ene_list = np.array([])
        self.fopt = None

    def logout_ori_data(self, logcsv_name):
        '''To logout the original data of this restraint group itself.

        Parameters
        ----------
        logcsv_name: str
            The output name of csv_file, note that the csv_file's delimitor is '|'.
        '''
        print(f'This is my restraint atoms [lig1, lig2, lig3, rec1, rec2, rec3] -- {self.restrain_group} All the lig* or rec* are atom number (starting from 1).')
        self.six_para_df.to_csv(logcsv_name, sep="|")

    def apply_fraction(self, array): 
        '''Applying the fraction to a np.array with shape of (N,), in which N is the number of frames.
        
        Parameters
        ----------
        array: np.array([])
            A np.array with shape of (N,), in which N is the number of frames.
        '''
        start = int(np.floor(array.shape[0]*(1-self.fraction)))
        return array[start:]
    
    def data_init(self, ):
        '''Initializing the data used for the calcene and fit analysis.
        
        Generated or update properties
        ----------
        self.dist_ary: np.array([])
            The array that stores all the data of r(DISTANCE ATOMS=lig1,rec1) in unit of nm.
        self.ang1_ary: np.array([])
            The array that stores all the data of thetaA(ANGLE ATOMS=lig1,rec1,rec2) in unit of Radian.
        self.ang2_ary: np.array([])
            The array that stores all the data of thetaB(ANGLE ATOMS=lig2,lig1,rec1) in unit of Radian.
        self.tor1_ary: np.array([])
            The array that stores all the data of phiA(TORSION ATOMS=rec3,rec2,rec1,lig1) in unit of Radian.
        self.tor2_ary: np.array([]) 
            The array that stores all the data of phiB(TORSION ATOMS=rec2,rec1,lig1,lig2) in unit of Radian.
        self.tor3_ary: np.array([])
            The array that stores all the data of phiC(TORSION ATOMS=rec1,lig1,lig2,lig3) in unit of Radian.    
        self.dist_mean = self.dist_ary.mean()  in unit of nm
        self.ang1_mean = self.ang1_ary.mean()  in unit of Radian
        self.ang2_mean = self.ang2_ary.mean()  in unit of Radian
        self.tor1_mean = self.cal_dihedral_mean(self.tor1_ary, 'radian', 'radian') in unit of Radian
        self.tor2_mean = self.cal_dihedral_mean(self.tor2_ary, 'radian', 'radian') in unit of Radian
        self.tor3_mean = self.cal_dihedral_mean(self.tor3_ary, 'radian', 'radian') in unit of Radian
        '''
        self.dist_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,0]))
        self.ang1_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,1]))
        self.ang2_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,2]))
        self.tor1_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,3]))
        self.tor2_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,4]))
        self.tor3_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,5]))
        self.dist_mean = self.dist_ary.mean() 
        self.ang1_mean = self.ang1_ary.mean() 
        self.ang2_mean = self.ang2_ary.mean() 
        self.tor1_mean = self.cal_dihedral_mean(self.tor1_ary, 'radian', 'radian')
        self.tor2_mean = self.cal_dihedral_mean(self.tor2_ary, 'radian', 'radian')
        self.tor3_mean = self.cal_dihedral_mean(self.tor3_ary, 'radian', 'radian')
    
    def cal_dihedral_mean(self, tor_array, input_unit, output_unit):
        '''Calculate the mean of dihedral in degree.
        
        Parameters
        ----------
        tor_array: np.array([])
            The array that stores the data of a dihedral in unit of Degree.
        input_unit: str
            'degree' or 'radian'
        output_unit: str
            'degree' or 'radian'
        
        Return
        ----------
        tor_mean: float
            The average value of the dihedral. 
        '''
        if input_unit == 'degree':
            pass
        elif input_unit == 'radian':
            tor_array = tor_array/np.pi*180
        else:
            print('Unsupported unit of input_unit!')
            sys.exit()
        
        summ = 0 
        tor_mean = 0
        count = 0
        for i in range(len(tor_array)):
            count += 1
            if count == 1:
                summ = tor_array[i] 
                tor_mean = summ/count
            else:
                if abs(tor_array[i]-tor_mean)>180:
                    if tor_array[i] < 0:
                        dihedral = tor_array[i]+360
                    elif tor_array[i] > 0:
                        dihedral = tor_array[i]-360
                    else:
                        dihedral = 0
                else:
                    dihedral = tor_array[i]
                summ += dihedral
                tor_mean = summ/count
        if output_unit == 'degree':
            pass
        elif output_unit == 'radian':
            tor_mean = tor_mean/180*np.pi
        else:
            print('Unsupported unit of output_unit!')
            sys.exit()
        
        return tor_mean

    def cal_harm_ene(self, d_0, d,  dihedral=False, k=41.84,):
        '''Calculate the harmonic energy for distance, angle or dihedral
        
        Parameters
        ----------
        d_0: float
            The value when the harmonic energy is equal to zero. Unit is A or rad.
        d: np.array([])
            The input array of the distance or angle or dihedral. Unit is A or rad.
        dihedral: bool
            To assign if calculate the dihedral typ of the harmonic energy.
        k: float, default: 41.84
            The force constant of calculated harmonic energy.
            For distance, the unit is kJ*mol^-1*A^-2
            For angle, the unit is kJ*mol^-1*rad^-2
            For dihedral, the unit is kJ*mol^-1*rad^-2

        Return
        ----------
        harm_ene: float
            The calculated harmonic energy, whose unit is kJ*mol^-1
        '''
        d_np=np.array(d, dtype='float32')
        delta=d_np-d_0

        if dihedral: 
            for i in range(len(delta)):
                if delta[i] < -np.pi:
                    delta[i] += 2*np.pi
                elif delta[i] > np.pi:
                    delta[i] -= 2*np.pi
        
        harm_ene = 1/2*k*(delta)**2
        return harm_ene
    
    def calcene(self, p=None): 
        '''Calculate the harmonic energy for six parameters and update the total restraint energy.
        
        Parameters
        ----------
        p: None or np.array
            When p is None, use the trajectory means as equilbrium values for the six geometric parameters.
            When p is a np.array, d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq = p, d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq is the determined equilbrium values for the r(DISTANCE ATOMS=lig1,rec1) in unit of nm, thetaA(ANGLE ATOMS=lig1,rec1,rec2), thetaB(ANGLE ATOMS=lig2,lig1,rec1) in unit of Radian, phiA(TORSION ATOMS=rec3,rec2,rec1,lig1) in unit of Radian, phiB(TORSION ATOMS=rec2,rec1,lig1,lig2) in unit of Radian and phiC(TORSION ATOMS=rec1,lig1,lig2,lig3) in unit of Radian.
        
        Generated or update properties
        ----------
        self.ene_list: np.array([])
            The np.array containing delta_U with shape of (N,), in which N is the number of frames after applying fraction, whose unit is kJ*mol^-1.
        self.ene: float
            The total restraint energy, whose unit is  kJ*mol^-1.
        self.delta_u: np.array([])
            The np.array of the delta_U, whose unit is kb_T.
        '''
        if p is None: 
            self.ene_list = self.cal_harm_ene(self.dist_mean*10, self.dist_ary*10) + self.cal_harm_ene(self.ang1_mean,self.ang1_ary) + self.cal_harm_ene(self.ang2_mean,self.ang2_ary) + self.cal_harm_ene(self.tor1_mean, self.tor1_ary, dihedral=True) + self.cal_harm_ene(self.tor2_mean, self.tor2_ary, dihedral=True) + self.cal_harm_ene(self.tor3_mean, self.tor3_ary, dihedral=True) 
        else:
            d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq = p
            self.ene_list = self.cal_harm_ene(d_eq*10, self.dist_ary*10) + self.cal_harm_ene(a1_eq,self.ang1_ary) + self.cal_harm_ene(a2_eq,self.ang2_ary) + self.cal_harm_ene(t1_eq, self.tor1_ary, dihedral=True) + self.cal_harm_ene(t2_eq, self.tor2_ary, dihedral=True) + self.cal_harm_ene(t3_eq, self.tor3_ary, dihedral=True)
        self.delta_u = np.array(self.ene_list)/2.478
        exponential=np.exp(self.delta_u*(-1))
        expave=exponential.mean()
        self.ene=-2.478*np.log(expave)


    def user_def_eqP_get_cost(self, p):
        '''Use the user-define equilbrium values of the six geometric parameters to calculate RED-E function cost.
        
        Parameters
        ----------
        p: None or np.array
            When p is None, use the trajectory means as equilbrium values for the six geometric parameters.
            When p is a np.array, d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq = p, d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq is the determined equilbrium values for the r(DISTANCE ATOMS=lig1,rec1) in unit of nm, thetaA(ANGLE ATOMS=lig1,rec1,rec2), thetaB(ANGLE ATOMS=lig2,lig1,rec1) in unit of Radian, phiA(TORSION ATOMS=rec3,rec2,rec1,lig1) in unit of Radian, phiB(TORSION ATOMS=rec2,rec1,lig1,lig2) in unit of Radian and phiC(TORSION ATOMS=rec1,lig1,lig2,lig3) in unit of Radian.
        '''
        self.calcene(p)
        self.fit()
        return self.fopt
    
    def user_def_eqP_get_dG(self, p):
        '''Use the user-define equilbrium values of the six geometric parameters to calculate dG_forward.
        
        Parameters
        ----------
        p: None or np.array
            When p is None, use the trajectory means as equilbrium values for the six geometric parameters.
            When p is a np.array, d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq = p, d_eq, a1_eq, a2_eq, t1_eq, t2_eq, t3_eq is the determined equilbrium values for the r(DISTANCE ATOMS=lig1,rec1) in unit of nm, thetaA(ANGLE ATOMS=lig1,rec1,rec2), thetaB(ANGLE ATOMS=lig2,lig1,rec1) in unit of Radian, phiA(TORSION ATOMS=rec3,rec2,rec1,lig1) in unit of Radian, phiB(TORSION ATOMS=rec2,rec1,lig1,lig2) in unit of Radian and phiC(TORSION ATOMS=rec1,lig1,lig2,lig3) in unit of Radian.
        '''
        self.calcene(p)
        return self.ene

    def opt_eqP(self, opt_cost_name='RED_E_cost'):
        '''

        Parameters
        ----------
        opt_cost_name: str
            The name of the optimization cost type. If it is 'RED_E_cost', the objective is the RED-E function cost (self.fopt). If it is 'dG_forward', the cost is the dG_forward (self.ene).
        '''
        if opt_cost_name == 'RED_E_cost':
            self.opt_eqP_RED_E_cost()
        elif opt_cost_name == 'dG_forward':
            self.opt_eqP_dG_forward()
        else:
            print('Unsupported opt_cost_name!')
            sys.exit()
    
    def opt_eqP_RED_E_cost():
        '''To optimize the equilbrium values of the six geometric parameters to minimize the RED-E function cost (self.fopt).
        '''
        p0 = np.array([self.dist_mean, self.ang1_mean, self.ang2_mean, self.tor1_mean, self.tor2_mean, self.tor3_mean])
        eqP = minimize(self.user_def_eqP_get_cost, p0, )
        self.eqP = eqP

    def fit(self):
        '''Fitting the self.ene_list by using RED function.
        
        Generated or update properties
        ----------
        self.fopt: float or None
            The initial value is None, and will be updated after Restraint Energy Distribution (RED) fitting,
            which is the cost of the fitting.
        self.w_fit: <class 'RED_FIT'>
            A class for RED function fitting analysis.
        '''
        self.w_fit=RED_FIT(self.ene_list,bins=100)
        self.fopt=self.w_fit.rd_fit()
        self.statics_info = {
            'theo_u_mean': self.w_fit.theo_u_mean,
            'theo_u_std': self.w_fit.theo_u_std,
            'theo_u_value_y_max': self.w_fit.theo_u_value_y_max,
            'sampled_u_mean': self.w_fit.sampled_u_mean,
            'sampled_u_std': self.w_fit.sampled_u_std,
            'sampled_u_value_y_max': self.w_fit.sampled_u_value_y_max,
        }   
        
    def draw_figure(self, filename, cut_bool=True):
        '''Draw the delta_U and fitting curve
        
        Parameters
        ----------
        filename: str
            Assigning for the output png file.
        cut_bool: bool
            When True, show the original delta_U and the cutted delta_U together.
            When False, only show the cutted delta_U.
        '''
        self.w_fit.show_fit(str(filename), cut_bool) 
    
    def analyze(self):
        '''To the self.calcene() and self.fit()
        '''
        self.calcene()
        self.fit()
        self.eqP = np.array([self.dist_mean, self.ang1_mean, self.ang2_mean, self.tor1_mean, self.tor2_mean, self.tor3_mean])
    
    def get_min_ene_index(self):
        '''To get the index of the frame with minimal restrain energy. For the possible following extraction of this frame as input structure. 
        Only work after self.analyze().
        
        Return 
        ----------
        index: int
            a int that is the index of frame with minimal restrain energy. (count from zero.)
        '''
        index = int(np.where(self.ene_list == self.ene_list.min())[0][0])
        return index

    def echo_rest_txt(self, software='gromacs'):
        dist_eq, ang1_eq, ang2_eq, tor1_eq, tor2_eq, tor3_eq = self.eqP # dist in unit of nm, angle or torsion in radian
        if software=='gromacs':
            res = self.restrain_group
            restr_str = '''
[ intermolecular_interactions ]
[ bonds ]
; ai   aj     type  bA     kA   bB     kB
{: >6d} {: <7d}6     {: <6.3f} 0.0  {: <6.3f} 4184.0

[ angles ]
; ai   aj   ak     type  thA     kA   thB     kB 
{: >6d} {: <4d} {: <4d}   1     {: <7.2f} 0.0  {: <7.2f} 41.84
{: >6d} {: <4d} {: <4d}   1     {: <7.2f} 0.0  {: <7.2f} 41.84

[ dihedrals ]
; ai   aj   ak   al      type  phiA    kA    phiB    kB 
{: >6d} {: <4d} {: <4d} {: <4d}    2     {: <7.2f} 0.0   {: <7.2f} 41.84
{: >6d} {: <4d} {: <4d} {: <4d}    2     {: <7.2f} 0.0   {: <7.2f} 41.84
{: >6d} {: <4d} {: <4d} {: <4d}    2     {: <7.2f} 0.0   {: <7.2f} 41.84
'''.format(res[0], res[3], dist_eq, dist_eq,
            res[1], res[0], res[3], ang2_eq/np.pi*180, ang2_eq/np.pi*180,
            res[0], res[3], res[4], ang1_eq/np.pi*180, ang1_eq/np.pi*180,
            res[2], res[1], res[0], res[3], tor3_eq/np.pi*180, tor3_eq/np.pi*180,
            res[1], res[0], res[3], res[4], tor2_eq/np.pi*180, tor2_eq/np.pi*180,
            res[0], res[3], res[4], res[5], tor1_eq/np.pi*180, tor1_eq/np.pi*180,
            )
            print(restr_str)
            return restr_str
        elif software=='openmm':
            res = self.restrain_group
            rec_atoms = [res[5]-1, res[4]-1, res[3]-1]
            lig_atoms = [res[0]-1, res[1]-1, res[2]-1]
            r = dist_eq*10
            theta1 = ang1_eq
            theta2 = ang2_eq
            phi1 = tor1_eq
            phi2 = tor2_eq
            phi3 = tor3_eq
            
            restr_str = f'Best restraint scheme is following: rec_atoms:{rec_atoms}(started from 0), lig_atoms:{lig_atoms}(started from 0), r:{r}, theta1:{theta1}, theta2:{theta2}, phi1:{phi1}, phi2:{phi2}, phi3:{phi3}'
            print(restr_str)
            return restr_str

    def get_res_parm_4_openmm(self, ):
        '''Generate the respective <class 'RestraintParam'> for openmm alchemical md

        Return 
        ----------
        res_parm: <class 'RestraintParam'>
            The class storing all the information needed for the BoreschLike restraint. 
        '''
        dist_eq, ang1_eq, ang2_eq, tor1_eq, tor2_eq, tor3_eq = self.eqP # dist in unit of nm, angle or torsion in radian
        res = self.restrain_group
        rec_atoms = [res[5]-1, res[4]-1, res[3]-1]
        lig_atoms = [res[0]-1, res[1]-1, res[2]-1]
        r = dist_eq*10
        res_parm = RestraintParam(rec_atoms,lig_atoms,r,ang1_eq,ang2_eq,tor1_eq,tor2_eq,tor3_eq)
        return res_parm


class ALL_Restrain_Data():
    def __init__(self, all_data_path, muti_six_atm_lst, fraction):
        '''Initializing
        
        Parameters
        ----------
        all_data_path: str
            The plumed output data's path.
            
        muti_six_atm_lst: list
            A list contain the six atoms for BoreschLike restrain, like [lig1, lig2, lig3, rec1, rec2, rec3], all the lig* or rec* are atom number (starting from 1) and int datatype. 
            For the BoreschLike restraint: 
            r: DISTANCE ATOMS=lig1, rec1
            thetaA: ANGLE ATOMS=lig1, rec1, rec2
            thetaB: ANGLE ATOMS=lig2, lig1, rec1
            phiA: TORSION ATOMS=rec3, rec2, rec1, lig1
            phiB: TORSION ATOMS=rec2, rec1, lig1, lig2
            phiC: TORSION ATOMS=rec1, lig1, lig2, lig3
        '''
        import re
        self.all_data_path = all_data_path
        self.muti_six_atm_lst = muti_six_atm_lst
        self.fraction = fraction
        jing_pattern = re.compile('^#.*')
        tmp = 'tmp.csv'
        tmp_file = open(tmp, 'w+')
        data_ = open(all_data_path, 'r')
        for line in data_.readlines():
            if jing_pattern.search(line) == None:
                print(line, file=tmp_file)
        tmp_file.close()
        all_df = pd.read_csv(tmp, header=None, delim_whitespace=True)
        
        num_of_grp_six_atom = len(self.muti_six_atm_lst)
        print(num_of_grp_six_atom)
        self.restrain_data_list = []
        for i in range(0, num_of_grp_six_atom):
            if i == 0:
                start_col = 1
            else:
                start_col = end_col
            end_col = start_col+6
            single_grp_df = all_df.iloc[:, start_col:end_col]
            single_grp = self.muti_six_atm_lst[i]
            self.restrain_data_list.append(Restrain_Data(single_grp, single_grp_df, self.fraction))
        os.remove('tmp.csv')
        self.ori_restrain_data_list = self.restrain_data_list
        print(f'Number of the restraint group: {len(self.ori_restrain_data_list)}')

    def logout_specific_grp_data(self, grp_idx, logcsv_name):
        '''To log out the specific restraint group's data.

        Parameters
        ----------
        grp_idx: int 
            The index of the restraint group.(Starting from 0)
        logcsv_name: str
            The output name of csv_file, note that the csv_file's delimitor is '|'.
        '''
        self.ori_restrain_data_list[grp_idx].logout_ori_data(logcsv_name)

    def process_data(self, ):
        '''Do the Restrain_Data.data_init() and Restrain_Data.analyze() for every restrain_data in self.restrain_data_list.
        '''
        time_start_1 = timeit.default_timer()
        for restrain_data in self.restrain_data_list:
            restrain_data.data_init()
            restrain_data.analyze()
        time_end_1 = timeit.default_timer()
        print('Calculating the restraints energy and fitting the delta U distribution cost: '+str(time_end_1-time_start_1)+' seconds.')
        
    def sort_result(self, ):
        '''First remove the restrain_data in the self.restrain_data_list with restrain.ene greater than 3 kcal/mol (12.552 kJ/mol),
        then sort the restrain_data by the restrain.fopt.
        
        Generated or update properties
        ----------
        self.restrain_data_list: list
            A list contain many <class 'Restrain_Data'>, with the restrain.ene smaller than or equal to 3 kcal/mol (12.552 kJ/mol).
        self.sorted_res_list: list
            A list contain many <class 'Restrain_Data'>, sorted by the <class 'Restrain_Data'>.fopt. 
        '''
        self.restrain_data_list = [i for i in self.restrain_data_list if i.ene < 12.552]
        self.restrain_data_list = [i for i in self.restrain_data_list if i.dist_ary.mean()*10 < 10]
        if self.restrain_data_list == []:
            print('The candidate restraint scheme are not suitable to the large restraint energy!')
            sys.exit()
        else:
            pass
        self.sorted_res_list = sorted(self.restrain_data_list, key=lambda x:x.fopt)
        return self.sorted_res_list
    
    def get_best_result(self, ):
        '''Get the best result by getting the front 10 or <10 <class 'Restrain_Data'> first and then sort by restrain energy.
        
        Return
        ----------
        best_result: <class 'Restrain_Data'>
        '''
        self.res_list_4_std_sort = []
        if len(self.sorted_res_list) < 10:
            for i in range(len(self.sorted_res_list)):
                self.res_list_4_std_sort.append(self.sorted_res_list[i])
        else:
            for i in range(10):
                self.res_list_4_std_sort.append(self.sorted_res_list[i])
        self.res_list_4_std_sort = sorted(self.res_list_4_std_sort, key=lambda x:x.ene)
        best_result = self.res_list_4_std_sort[0]
        pd.DataFrame(best_result.statics_info, index=[0,]).to_csv('statics_info.csv')
        return best_result
    
    def generate_csv(self, csv_name, lst):
        '''To log the analysis result.
        '''
        #idx_lst = [i for i in range(0,len(lst))]
        column_lst = ['restraint_atom[lig1, lig2, lig3, rec1, rec2, rec3](start from 1)', 'rec_atoms[rec3, rec2, rec1](start from 0)', 'lig_atoms[lig1, lig2, lig3](start from 0)', 'distance between lig1 and rec1(unit: Angstrom)', 'angle between lig1 rec1 and rec2(unit:radian)','angle between lig2 lig1 and rec1(unit:radian)',\
        'dihedral between lig1 rec1 rec2 and rec3(unit:radian)', 'dihedral between lig2 lig1 rec1 and rec2(unit:radian)', 'dihedral between lig3 lig2 lig1 and rec1(unit:radian)', 'cal_ene(unit:kcal/mol)', 'cost function value']
 
        self.all_data = pd.concat([pd.DataFrame({'restraint_atom[lig1, lig2, lig3, rec1, rec2, rec3](start from 1)': [i.restrain_group,], 
                                            'rec_atoms[rec3, rec2, rec1](start from 0)': [[i.restrain_group[5]-1, i.restrain_group[4]-1, i.restrain_group[3]-1],],
                                            'lig_atoms[lig1, lig2, lig3](start from 0)': [[i.restrain_group[0]-1, i.restrain_group[1]-1, i.restrain_group[2]-1],],
                                            'distance between lig1 and rec1(unit: Angstrom)': [i.dist_ary.mean()*10],
                                            'angle between lig1 rec1 and rec2(unit:radian)': [i.ang1_ary.mean()],
                                            'angle between lig2 lig1 and rec1(unit:radian)': [i.ang2_ary.mean()],
                                            'dihedral between lig1 rec1 rec2 and rec3(unit:radian)': [i.cal_dihedral_mean(i.tor1_ary, 'radian', 'radian')],
                                            'dihedral between lig2 lig1 rec1 and rec2(unit:radian)': [i.cal_dihedral_mean(i.tor2_ary, 'radian', 'radian')], 
                                            'dihedral between lig3 lig2 lig1 and rec1(unit:radian)': [i.cal_dihedral_mean(i.tor3_ary, 'radian', 'radian')], 
                                            'cal_ene(unit:kcal/mol)': [i.ene/4.184],
                                            'cost function value': [i.fopt],    
                                            }, 
                                columns=column_lst,) 
                                for i in lst],ignore_index=True)
        #print(self.all_data)
        self.all_data.to_csv(csv_name,index=True)




class RestraintParam():
    def __init__(self, rec_atoms, lig_atoms, r, theta1, theta2, phi1, phi2, phi3, kbond=10, kangle=10, kdihedral=10):
        self.rec_atoms = rec_atoms # [rec3, rec2, rec1] started from 0
        self.lig_atoms = lig_atoms # [lig1, lig2, lig3] started from 0
        self.r = r # distance between rec1 and lig1, unit in Angstrom
        self.theta1 = theta1 # angle between rec2, rec1, lig1, unit in radians
        self.theta2 = theta2 # angle between rec1, lig1, lig2
        self.phi1 = phi1 # dihedral between rec3, rec2, rec1, lig1
        self.phi2 = phi2 # dihedral between rec2, rec1, lig1, lig2
        self.phi3 = phi3 # dihedral between rec1, lig1, lig2, lig3
        self.kbond = kbond # unit in kcal/mol/A^2
        self.kangle = kangle # unit in kcal/mol/rad^2
        self.kdihedral = kdihedral # unit in kcal/mol/rad^2
    def __repr__(self):
        return f'rec_atoms:{self.rec_atoms}, lig_atoms:{self.lig_atoms}, r:{self.r} A, theta1:{self.theta1} rad, theta2:{self.theta2} rad, phi1:{self.phi1} rad, phi2:{self.phi2} rad, phi3:{self.phi3} rad, kbond:{self.kbond} kcal/mol/A^2, kangle:{self.kangle} kcal/mol/rad^2, self.kdihedral:{self.kdihedral} kcal/mol/rad^2'
    def gen_measure_plumed(self, plumed_file_path, plumed_logout, output_frq):
        muti_six_atm_lst = [[self.lig_atoms[0]+1, self.lig_atoms[1]+1, self.lig_atoms[2]+1, self.rec_atoms[2]+1, self.rec_atoms[1]+1, self.rec_atoms[0]+1],]
        Plumed_gen_obj = Gen_plumed_input(muti_six_atm_lst)
        Plumed_gen_obj.gen_BoreschLike_measure(plumed_file_path, plumed_logout, output_frq)


if __name__ == '__main__':
    all_data_path = 'Colvar'
    muti_six_atm_lst = eval(open('./all_lst', 'r').read())
    res = ALL_Restrain_Data(all_data_path=all_data_path, muti_six_atm_lst=muti_six_atm_lst, fraction=0.75)
    res.process_data()
    res.generate_csv(csv_name="res_data_ori.csv", lst=res.restrain_data_list)
    res.generate_csv(csv_name="res_databyfopt.csv", lst=res.sort_result())

    lst_z = eval(open('./based_lig_shape', 'r').read())
    lst_a = eval(open('./based_HB_pair', 'r').read())
    lst_b = eval(open('./based_HB_mainchain', 'r').read())
    
    count = -1
    for i in res.sort_result():
        count+=1
        if count < 20:
            print('The serial number is {}.'.format(str(count+1)))
            if i.restrain_group in lst_z:
                print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by first strategy.')
                print('The cost function value is '+str(i.fopt))
            elif i.restrain_group in lst_a:
                print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by second strategy.')
                print('The cost function value is '+str(i.fopt))
            else:
                print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by third strategy.')
                print('The cost function value is '+str(i.fopt))
    best=res.get_best_result()

    res_parm = best.get_res_parm_4_openmm()
    
    np.savetxt('pre_w_f',best.delta_u) 
    res.generate_csv(csv_name="res_databystd.csv", lst=res.res_list_4_std_sort)
    best.draw_figure('best.png')
    with open('restr.txt', 'w') as restr_file:  
        restr_file.write(best.echo_rest_txt('openmm'))
