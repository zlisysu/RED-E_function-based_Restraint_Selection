from scipy import optimize
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import sys 
import numpy as np
import timeit
import pandas as pd
import os
from .gen_plumed import Gen_plumed_input

class RED_FIT():
    '''Restraint Energy Distribution(RED) function based fitting for the delta_U probability distribution.

    '''
    def __init__(self, d_u, bins=100):
        '''Initializing
        
        Parameters
        ----------
        d_u: array_like
            A series of delta_U values ((U_restrained - U_free) or (U_restrained - U_free)) with unit of kbT.
        bins: int, default: 100
            The bins used to generate the histogram of d_u.
        
        Key properties
        ----------
        self.u_l: np.array
            A series of delta_U values ((U_restrained - U_free) or (U_restrained - U_free)) with unit of kbT. 
            Its initial value was as same as the d_u. Then self.u_l will be filtered and reserve the delta_U, which is smaller than the five times of the theoretical mean of the delta_U (In RED function, the mean of delta_U is equal to the 2 times of the delta_U values with the highest probability.)
        self.pu_arr_orig: array_like
            The normalized probability of the original d_u generated by the np.histogram(self.u_l, bins=bins, density=True) (before filteration of self.u_l )
        self.xu_orig: np.array
            It have the same shape of self.pu_arr_orig, in which everyone is the midpoint value of each bin.
        self.pu_arr: np.array
             The normalized probability of the filtered d_u generated by the np.histogram(self.u_l, bins=bins, density=True) (after filteration of self.u_l )
        self.xu_arr: np.array
            It have the same shape of self.pu_arr, in which everyone is the midpoint value of each bin.
        self.u_mean: float
            The actual mean value of the filtered self.u_l
        self.u_std: float
            The actual standard deviation of the filtered self.u_l
        '''
        self.u_l=np.array(d_u)
        self.u_mean = np.mean(self.u_l)
        self.pu_arr_orig,xu_arr_add1_orig = np.histogram(self.u_l,bins=bins,density=True)
        xu_orig = []
        for i in range(len(xu_arr_add1_orig)-1):
            xu_orig.append((xu_arr_add1_orig[i]+xu_arr_add1_orig[i+1])/2)
        self.xu_arr_orig = np.array(xu_orig)        
        y_max = self.pu_arr_orig.max()
        #print (np.where(self.pu_arr_orig == y_max))
        #print (np.where(self.pu_arr_orig == y_max)[0])
        index = int(np.where(self.pu_arr_orig == y_max)[0][0])
        #print (index)
        x_max = self.xu_arr_orig[index] #the point with the highest y value
        
        mean = 2 * x_max # can be derived based on the equation b^2*exp(-bx)*x
        # self.u_l = self.u_l[self.u_l< (6*mean)]
        self.b_guess_by_max = 1/x_max
        
        self.pu_arr,xu_arr_add1 = np.histogram(self.u_l,bins=bins,density=True)
        xu = []
        for i in range(len(xu_arr_add1)-1):
            xu.append((xu_arr_add1[i]+xu_arr_add1[i+1])/2)

        self.xu_arr = np.array(xu)
        self.b_guess_by_mean = 2/self.u_mean
        # self.pu_arr = self.pu_arr/self.b_guess_by_max
        # self.xu_arr = self.xu_arr/self.b_guess_by_max
        self.pu_arr = self.pu_arr[self.xu_arr< (5*mean)]
        self.xu_arr = self.xu_arr[self.xu_arr< (5*mean)]

        where_are_inf = np.isinf(self.u_l)
        if self.u_mean > 0:
            self.u_l[where_are_inf] = 999.0
        else:
            self.u_l[where_are_inf] = -999.0

        self.u_std = np.std(self.u_l)

        self.sampled_u_mean = np.sum(self.pu_arr * self.xu_arr) / np.sum(self.pu_arr)
        self.sampled_u_std  = np.sqrt(np.sum(self.pu_arr * (self.xu_arr - self.sampled_u_mean)**2) / np.sum(self.pu_arr))
        self.sampled_u_value_y_max  = x_max
      
        
    def residues_common(self,p,f,y,x):
        '''Calculate the sum of squares of the difference between the model predicted value and the actual sampled value.

        Parameters
        ----------
        p: np.array or float
            The parameter that may be optimized in the function.
        f: function
            The function receive p and x to get the predicted y.
        y: np.array
            The acutal sampled values.
        x: np.array
            The independent variable of the function.
        
        Return
        ----------
        np.sum((y-f(p,x))**2)
        '''
        return np.sum((y-f(p,x))**2)

    def gm4rd(self,p,x):
        '''Restraint energy distribution (RED) function. $P\left(\Delta U_{i+1, i}\right)=b^{2} \exp \left(-b \Delta U_{i+1, i}\right) \cdot\left(\Delta U_{i+1, i}\right)$
        RED function's distribution property: U_mean = 2/b; U_max = 1/b; U_std = 2^(1/2)/b
                
        Parameters
        ----------
        p: np.array
            The parameter that may be optimized in the function, which only contain the b1.
        x: np.array
            The independent variable of the function. (In RED function, they are series of delta_U)
 
        Return
        ----------
        (b1**2) * abs(x) * np.exp(-b1 * abs(x))
        '''
        b1 = p[0]
        #return  np.exp(b1-a1) * x**2 * np.exp(-b1 * x - c1 * x**10)
        return (b1**2) * abs(x) * np.exp(-b1 * abs(x) )  #b1**2 term is for normalization                                           
                        
    def residues_rd(self,p,f,y,x):
        '''
        Not finished
        '''
        # return np.sum(((y-f(p,x))**2)*np.exp(y))# To make the large y have great weight when optimizing cost
        # return np.sum(((y-f(p,x))*self.u_mean*self.u_mean)**2)# To plus u_mean twice for f(p,x)=4*abs(x)*np.exp(-b * abs(x)) because u_mean = 2/b
        return np.sum(((y-f(p,x))*self.u_mean/2)**2)# The larger u_mean will lead to the larger u_std since U_mean = 2/b and U_std = 2^(1/2)/b. For getting the distribution with small u_mean(u_std) when ranking.
        # return np.sum(((y-f(p,x))*((self.u_mean/2)**2)*np.exp((2/self.u_mean)*x))**2)
        # return np.sum(((y-f(p,x))*((self.u_mean/2)**2)/np.exp(-1))**2)
        # return np.sum(((y-f(p,x*self.u_mean/2))*self.u_mean/2)**2)
        # return  np.sum(((y-f(p,x))**2)/x)
        # return np.sum((y-f(p,x))**2)


    def func_fit(self,func,p0,residues,add00=False):
        '''Relatively common curve fitting method.

        Parameters
        ----------
        func: function
            The function receive p and x to get the predicted y, as the second parameter of resides.
        p0: np.array or float
            The parameter that may be optimized in the function.
        residues: function
            The cost function which receive the optimized parameter, the potential functions that describe probability distributions, the distribution x and y for fitting. 
        add00: bool
            Judge if the do the edge smoothing.
        
        Return
        ----------
        plsq_full: tuple
            The tuple contains 5 elements. We need the first and second element. The first element is a np.array containing the parameter that was optimized in the function. The second element is the final cost function's value. 
        '''
        fit_xu_arr=self.xu_arr
        fit_pu_arr=self.pu_arr
        
        if add00:
            fit_xu_arr = np.append(fit_xu_arr,0.0)
            fit_pu_arr = np.append(fit_pu_arr,0.0)
            if self.u_mean > 0:            
                maxval = fit_xu_arr.max()
                for i in range(5):
                    fit_xu_arr = np.append(fit_xu_arr,maxval+0.5*(i+1))
                    fit_pu_arr = np.append(fit_pu_arr,0.0)
            else:
                minval = fit_xu_arr.min()
                for i in range(5):
                    fit_xu_arr = np.append(fit_xu_arr,minval-0.5*(i+1))
                    fit_pu_arr = np.append(fit_pu_arr,0.0)
        plsq_full = optimize.fmin(residues, p0, args=(func, fit_pu_arr, fit_xu_arr),maxiter=100000, full_output=True)
        # plsq_full = optimize.minimize(residues, p0, args=(func, fit_pu_arr, fit_xu_arr),maxiter=100000, full_output=True)
        return plsq_full


    def rd_fit(self):
        '''Restraint energy distribution fit. We derived the relationship between the mean delta_U and b1 based on the RED function, which is 
$\begin{aligned}
\langle\Delta U\rangle &=\int_{0}^{\infty} \Delta U \cdot P(\Delta U) d \Delta U \\
&=\int_{0}^{\infty} b^{2} \cdot \Delta U^{2} \cdot e^{-b \Delta U} d \Delta U \\
&=\frac{2}{b}
\end{aligned}$ 
For the initial guess value b1 in the RED function, we used the value of 2/<delta_U>.

        Generated or update properties
        ----------
        self.x: np.array
            10000 points between 0 and the maximum value of self.u_l (when the mean value of self.u_l is greater than 0), or 10000 points between the minimum value of self.u_l and 0 (when the mean value of self.u_l is less than 0)
        self.fitted_y: np.array
            A series of predicted probability values obtained by substituting self.x into the RED function.
        self.fitted_u: np.array
            Based on the probability distribution generated by self.fitted_y and self.x resampling, each bin value in self.x is repeated 1000 times according to the corresponding self.fitted_y.
        
        Return 
        ----------
        fopt: float
            The cost value of the RED function fitting.
        '''
        b1=2/self.u_mean
        p0=np.array([b1,])
        plsq_collect=self.func_fit(self.gm4rd,p0,self.residues_rd,add00=True)
        print('plsq_collect:')
        print(plsq_collect)
        # plsq_collect=self.func_fit(self.gm4rd,p0,self.residues_rd,add00=True)
        plsq=plsq_collect[0]
        fopt=plsq_collect[1]

        self.fitted_b = plsq_collect[0][0]
        self.theo_u_mean = 2/self.fitted_b 
        self.theo_u_value_y_max = 1/self.fitted_b
        self.theo_u_std  = 2**(0.5)/self.fitted_b
        if self.u_mean > 0:
            self.x = np.linspace(0, 1.0*self.u_l.max(),10000)
        else:
            self.x = np.linspace(1.0*self.u_l.min(),0, 10000)
        self.fitted_y = self.gm4rd(plsq,self.x)  
        # self.fitted_y = self.gm4rd(plsq,self.x*self.u_mean/2)*self.u_mean/2 
        self.fitted_u=[]
        for i in range(len(self.x)):
            self.fitted_u += [self.x[i] for j in range(int(round(self.fitted_y[i]*1000.0)))]
        self.fitted_u=np.array(self.fitted_u)
        
        return fopt
        
    def show_fit(self,pngfile,show_ori=True):
        '''Show the scatter points used for the fit, all the original scatter points (optional) and the fitted curve(RED function).

        Parameters
        ---------- 
        pngfile: str
            The name of the output png file.
        show_ori: bool
            If show all the original scatter points.       
        '''
        plt.clf()
        plt.figure(figsize=(16.2,12))
        #plt.title("Fitted probability distribution", fontsize=40) 
        #plt.xlabel("delta_U/${k_B}$T", fontsize=40) 
        #plt.ylabel("Probability density", fontsize=40) 
        plt.tick_params(labelsize=33, width=6.0, length=8.0)
        ax=plt.gca()
        ax.spines['bottom'].set_linewidth(4)
        ax.spines['left'].set_linewidth(4)
        ax.spines['right'].set_linewidth(4)
        ax.spines['top'].set_linewidth(4)
        print(f'best fit: b_guess_by_mean: {self.b_guess_by_mean}, b_guess_by_max: {self.b_guess_by_max}, fitted_b: {self.fitted_b}')
        plt.plot(self.xu_arr,self.pu_arr,"o", color = "green", markersize=10)
        if show_ori:
            plt.plot(self.xu_arr_orig, self.pu_arr_orig, "o", color = "gray", markersize=10)
        else:
            pass
        plt.plot(self.x, self.fitted_y, color='red', linewidth=5)

        if not pngfile:
            plt.show()
        else:
            plt.savefig(pngfile, transparent=True)

    def show_original_data(self):
        '''Show the original scatter points plot
        '''
        plt.clf()
        plt.figure(figsize=(16.2,12))
        plt.tick_params(labelsize=33, width=6.0, length=8.0)
        ax=plt.gca()
        ax.spines['bottom'].set_linewidth(4)
        ax.spines['left'].set_linewidth(4)
        ax.spines['right'].set_linewidth(4)
        ax.spines['top'].set_linewidth(4)
        plt.plot(self.xu_arr,self.pu_arr,"o")  
        plt.show()


class Restrain_Data():
    def __init__(self, restrain_group, six_para_df, fraction, ):
        '''Initializing
        
        Parameters
        ----------
        restrain_group: list
            A list containing the index of the six atoms needed for restraint, 
            like [lig1, lig2, lig3, rec1, rec2, rec3], all the lig* or rec* are atom number (starting from 1) and int datatype.  
        fraction: float
            The float for assigning what percentage of the data used in the analysis.
        six_para_df: pd.DataFrame
            The DataFrame with shape of (N, 6), in which N is the number of frames.
            six_para_df.iloc[:,0] is the column that stores all the data of r(DISTANCE ATOMS=lig1,rec1)
            six_para_df.iloc[:,1] is the column that stores all the data of thetaA(ANGLE ATOMS=lig1,rec1,rec2)
            six_para_df.iloc[:,2] is the column that stores all the data of thetaB(ANGLE ATOMS=lig2,lig1,rec1)
            six_para_df.iloc[:,3] is the column that stores all the data of phiA(TORSION ATOMS=rec3,rec2,rec1,lig1)
            six_para_df.iloc[:,4] is the column that stores all the data of phiB(TORSION ATOMS=rec2,rec1,lig1,lig2)
            six_para_df.iloc[:,5] is the column that stores all the data of phiC(TORSION ATOMS=rec1,lig1,lig2,lig3)
            
        Key properties
        ----------
        self.ene_list: np.array([])
            The np.array with shape of (N,), in which N is the number of frames after applying fraction, whose unit is kJ*mol^-1.
        self.fopt: float or None
            The initial value is None, and will be updated after Restraint Energy Distribution (RED) fitting,
            which is the cost of the fitting.
        ''' 
        self.restrain_group = restrain_group
        self.six_para_df = six_para_df
        self.six_para_df.columns = ['r(DISTANCE ATOMS=lig1,rec1)', 'thetaA(ANGLE ATOMS=lig1,rec1,rec2)', 'thetaB(ANGLE ATOMS=lig2,lig1,rec1)', 'phiA(TORSION ATOMS=rec3,rec2,rec1,lig1)', 'phiB(TORSION ATOMS=rec2,rec1,lig1,lig2)', 'phiC(TORSION ATOMS=rec1,lig1,lig2,lig3)']
        self.fraction = fraction
        
        self.ene_list = np.array([])
        self.fopt = None

    def logout_ori_data(self, logcsv_name):
        '''To logout the original data of this restraint group itself.

        Parameters
        ----------
        logcsv_name: str
            The output name of csv_file, note that the csv_file's delimitor is '|'.
        '''
        print(f'This is my restraint atoms [lig1, lig2, lig3, rec1, rec2, rec3] -- {self.restrain_group} All the lig* or rec* are atom number (starting from 1).')
        self.six_para_df.to_csv(logcsv_name, sep="|")

    def apply_fraction(self, array): 
        '''Applying the fraction to a np.array with shape of (N,), in which N is the number of frames.
        
        Parameters
        ----------
        array: np.array([])
            A np.array with shape of (N,), in which N is the number of frames.
        '''
        start = int(np.floor(array.shape[0]*(1-self.fraction)))
        return array[start:]
    
    def data_init(self, ):
        '''Initializing the data used for the calcene and fit analysis.
        
        Generated or update properties
        ----------
        self.dist_ary: np.array([])
            The array that stores all the data of r(DISTANCE ATOMS=lig1,rec1) in unit of nm.
        self.ang1_ary: np.array([])
            The array that stores all the data of thetaA(ANGLE ATOMS=lig1,rec1,rec2) in unit of Radian.
        self.ang2_ary: np.array([])
            The array that stores all the data of thetaB(ANGLE ATOMS=lig2,lig1,rec1) in unit of Radian.
        self.tor1_ary: np.array([])
            The array that stores all the data of phiA(TORSION ATOMS=rec3,rec2,rec1,lig1) in unit of Radian.
        self.tor2_ary: np.array([]) 
            The array that stores all the data of phiB(TORSION ATOMS=rec2,rec1,lig1,lig2) in unit of Radian.
        self.tor3_ary: np.array([])
            The array that stores all the data of phiC(TORSION ATOMS=rec1,lig1,lig2,lig3) in unit of Radian.       
        '''
        self.dist_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,0]))
        self.ang1_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,1]))
        self.ang2_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,2]))
        self.tor1_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,3]))
        self.tor2_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,4]))
        self.tor3_ary = self.apply_fraction(np.array(self.six_para_df.iloc[:,5]))
    
    def cal_dihedral_mean(self, tor_array, input_unit, output_unit):
        '''Calculate the mean of dihedral in degree.
        
        Parameters
        ----------
        tor_array: np.array([])
            The array that stores the data of a dihedral in unit of Degree.
        input_unit: str
            'degree' or 'radian'
        output_unit: str
            'degree' or 'radian'
        
        Return
        ----------
        tor_mean: float
            The average value of the dihedral. 
        '''
        if input_unit == 'degree':
            pass
        elif input_unit == 'radian':
            tor_array = tor_array/np.pi*180
        else:
            print('Unsupported unit of input_unit!')
            sys.exit()
        
        summ = 0 
        tor_mean = 0
        count = 0
        for i in range(len(tor_array)):
            count += 1
            if count == 1:
                summ = tor_array[i] 
                tor_mean = summ/count
            else:
                if abs(tor_array[i]-tor_mean)>180:
                    if tor_array[i] < 0:
                        dihedral = tor_array[i]+360
                    elif tor_array[i] > 0:
                        dihedral = tor_array[i]-360
                    else:
                        dihedral = 0
                else:
                    dihedral = tor_array[i]
                summ += dihedral
                tor_mean = summ/count
        if output_unit == 'degree':
            pass
        elif output_unit == 'radian':
            tor_mean = tor_mean/180*np.pi
        else:
            print('Unsupported unit of output_unit!')
            sys.exit()
        
        return tor_mean

    def cal_harm_ene(self, d_0, d,  dihedral=False, k=41.84,):
        '''Calculate the harmonic energy for distance, angle or dihedral
        
        Parameters
        ----------
        d_0: float
            The value when the harmonic energy is equal to zero. Unit is A or rad.
        d: np.array([])
            The input array of the distance or angle or dihedral. Unit is A or rad.
        dihedral: bool
            To assign if calculate the dihedral typ of the harmonic energy.
        k: float, default: 41.84
            The force constant of calculated harmonic energy.
            For distance, the unit is kJ*mol^-1*A^-2
            For angle, the unit is kJ*mol^-1*rad^-2
            For dihedral, the unit is kJ*mol^-1*rad^-2

        Return
        ----------
        harm_ene: float
            The calculated harmonic energy, whose unit is kJ*mol^-1
        '''
        d_np=np.array(d, dtype='float32')
        delta=d_np-d_0

        if dihedral: 
            for i in range(len(delta)):
                if delta[i] < -np.pi:
                    delta[i] += 2*np.pi
                elif delta[i] > np.pi:
                    delta[i] -= 2*np.pi
        
        harm_ene = 1/2*k*(delta)**2
        return harm_ene
    
    def calcene(self): 
        '''Calculate the harmonic energy for six parameters and update the total restraint energy.
        
        Generated or update properties
        ----------
        self.ene_list: np.array([])
            The np.array containing delta_U with shape of (N,), in which N is the number of frames after applying fraction, whose unit is kJ*mol^-1.
        self.ene: float
            The total restraint energy, whose unit is  kJ*mol^-1.
        self.delta_u: np.array([])
            The np.array of the delta_U, whose unit is kb_T.
        '''
        tor1_mean = self.cal_dihedral_mean(self.tor1_ary, 'radian', 'radian')
        tor2_mean = self.cal_dihedral_mean(self.tor2_ary, 'radian', 'radian')
        tor3_mean = self.cal_dihedral_mean(self.tor3_ary, 'radian', 'radian')
        
        self.ene_list = self.cal_harm_ene(self.dist_ary.mean()*10, self.dist_ary*10) + self.cal_harm_ene(self.ang1_ary.mean()/180.0*np.pi,self.ang1_ary/180.0*np.pi) + self.cal_harm_ene(self.ang2_ary.mean()/180.0*np.pi,self.ang2_ary/180.0*np.pi) + self.cal_harm_ene(tor1_mean, self.tor1_ary, dihedral=True) + self.cal_harm_ene(tor2_mean, self.tor3_ary, dihedral=True) + self.cal_harm_ene(tor3_mean, self.tor3_ary, dihedral=True) 
        self.delta_u = np.array(self.ene_list)/2.478
        exponential=np.exp(self.delta_u*(-1))
        expave=exponential.mean()
        self.ene=-2.478*np.log(expave)
        
    def fit(self):
        '''Fitting the self.ene_list by using RED function.
        
        Generated or update properties
        ----------
        self.fopt: float or None
            The initial value is None, and will be updated after Restraint Energy Distribution (RED) fitting,
            which is the cost of the fitting.
        self.w_fit: <class 'RED_FIT'>
            A class for RED function fitting analysis.
        '''
        self.w_fit=RED_FIT(self.ene_list,bins=100)
        self.fopt=self.w_fit.rd_fit()
        self.statics_info = {
            'theo_u_mean': self.w_fit.theo_u_mean,
            'theo_u_std': self.w_fit.theo_u_std,
            'theo_u_value_y_max': self.w_fit.theo_u_value_y_max,
            'sampled_u_mean': self.w_fit.sampled_u_mean,
            'sampled_u_std': self.w_fit.sampled_u_std,
            'sampled_u_value_y_max': self.w_fit.sampled_u_value_y_max,
        }   
        
    def draw_figure(self, filename, cut_bool=True):
        '''Draw the delta_U and fitting curve
        
        Parameters
        ----------
        filename: str
            Assigning for the output png file.
        cut_bool: bool
            When True, show the original delta_U and the cutted delta_U together.
            When False, only show the cutted delta_U.
        '''
        self.w_fit.show_fit(str(filename), cut_bool) 
    
    def analyze(self):
        '''To the self.calcene() and self.fit()
        '''
        self.calcene()
        self.fit()
    
    def get_min_ene_index(self):
        '''To get the index of the frame with minimal restrain energy. For the possible following extraction of this frame as input structure. 
        Only work after self.analyze().
        
        Return 
        ----------
        index: int
            a int that is the index of frame with minimal restrain energy. (count from zero.)
        '''
        index = int(np.where(self.ene_list == self.ene_list.min())[0][0])
        return index

    def echo_rest_txt(self, software='gromacs'):
        if software=='gromacs':
            res = self.restrain_group
            restr_str = '''
[ intermolecular_interactions ]
[ bonds ]
; ai   aj     type  bA     kA   bB     kB
{: >6d} {: <7d}6     {: <6.3f} 0.0  {: <6.3f} 4184.0

[ angles ]
; ai   aj   ak     type  thA     kA   thB     kB 
{: >6d} {: <4d} {: <4d}   1     {: <7.2f} 0.0  {: <7.2f} 41.84
{: >6d} {: <4d} {: <4d}   1     {: <7.2f} 0.0  {: <7.2f} 41.84

[ dihedrals ]
; ai   aj   ak   al      type  phiA    kA    phiB    kB 
{: >6d} {: <4d} {: <4d} {: <4d}    2     {: <7.2f} 0.0   {: <7.2f} 41.84
{: >6d} {: <4d} {: <4d} {: <4d}    2     {: <7.2f} 0.0   {: <7.2f} 41.84
{: >6d} {: <4d} {: <4d} {: <4d}    2     {: <7.2f} 0.0   {: <7.2f} 41.84
'''.format(res[0], res[3], self.dist_ary.mean(), self.dist_ary.mean(),
            res[1], res[0], res[3], self.ang2_ary.mean(), self.ang2_ary.mean(),
            res[0], res[3], res[4], self.ang1_ary.mean(), self.ang1_ary.mean(),
            res[2], res[1], res[0], res[3], self.cal_dihedral_mean(self.tor3_ary, 'radian', 'degree'), self.cal_dihedral_mean(self.tor3_ary, 'radian', 'degree'),
            res[1], res[0], res[3], res[4], self.cal_dihedral_mean(self.tor2_ary, 'radian', 'degree'), self.cal_dihedral_mean(self.tor2_ary, 'radian', 'degree'),
            res[0], res[3], res[4], res[5], self.cal_dihedral_mean(self.tor1_ary, 'radian', 'degree'), self.cal_dihedral_mean(self.tor1_ary, 'radian', 'degree'),
            )
            print(restr_str)
            return restr_str
        elif software=='openmm':
            res = self.restrain_group
            rec_atoms = [res[5]-1, res[4]-1, res[3]-1]
            lig_atoms = [res[0]-1, res[1]-1, res[2]-1]
            r = self.dist_ary.mean()*10
            theta1 = self.ang1_ary.mean()
            theta2 = self.ang2_ary.mean()
            phi1 = self.cal_dihedral_mean(self.tor1_ary, 'radian', 'radian')
            phi2 = self.cal_dihedral_mean(self.tor2_ary, 'radian', 'radian')
            phi3 = self.cal_dihedral_mean(self.tor3_ary, 'radian', 'radian')
            
            restr_str = f'Best restraint scheme is following: rec_atoms:{rec_atoms}(started from 0), lig_atoms:{lig_atoms}(started from 0), r:{r}, theta1:{theta1}, theta2:{theta2}, phi1:{phi1}, phi2:{phi2}, phi3:{phi3}'
            print(restr_str)
            return restr_str

    def get_res_parm_4_openmm(self, ):
        '''Generate the respective <class 'RestraintParam'> for openmm alchemical md

        Return 
        ----------
        res_parm: <class 'RestraintParam'>
            The class storing all the information needed for the BoreschLike restraint. 
        '''
        res = self.restrain_group
        rec_atoms = [res[5]-1, res[4]-1, res[3]-1]
        lig_atoms = [res[0]-1, res[1]-1, res[2]-1]
        r = self.dist_ary.mean()*10
        theta1 = self.ang1_ary.mean()
        theta2 = self.ang2_ary.mean()
        phi1 = self.cal_dihedral_mean(self.tor1_ary, 'radian', 'radian')
        phi2 = self.cal_dihedral_mean(self.tor2_ary, 'radian', 'radian')
        phi3 = self.cal_dihedral_mean(self.tor3_ary, 'radian', 'radian')
        res_parm = RestraintParam(rec_atoms,lig_atoms,r,theta1,theta2,phi1,phi2,phi3)
        return res_parm


class ALL_Restrain_Data():
    def __init__(self, all_data_path, muti_six_atm_lst, fraction):
        '''Initializing
        
        Parameters
        ----------
        all_data_path: str
            The plumed output data's path.
            
        muti_six_atm_lst: list
            A list contain the six atoms for BoreschLike restrain, like [lig1, lig2, lig3, rec1, rec2, rec3], all the lig* or rec* are atom number (starting from 1) and int datatype. 
            For the BoreschLike restraint: 
            r: DISTANCE ATOMS=lig1, rec1
            thetaA: ANGLE ATOMS=lig1, rec1, rec2
            thetaB: ANGLE ATOMS=lig2, lig1, rec1
            phiA: TORSION ATOMS=rec3, rec2, rec1, lig1
            phiB: TORSION ATOMS=rec2, rec1, lig1, lig2
            phiC: TORSION ATOMS=rec1, lig1, lig2, lig3
        '''
        import re
        self.all_data_path = all_data_path
        self.muti_six_atm_lst = muti_six_atm_lst
        self.fraction = fraction
        jing_pattern = re.compile('^#.*')
        tmp = 'tmp.csv'
        tmp_file = open(tmp, 'w+')
        data_ = open(all_data_path, 'r')
        for line in data_.readlines():
            if jing_pattern.search(line) == None:
                print(line, file=tmp_file)
        tmp_file.close()
        all_df = pd.read_csv(tmp, header=None, delim_whitespace=True)
        
        num_of_grp_six_atom = len(self.muti_six_atm_lst)
        print(num_of_grp_six_atom)
        self.restrain_data_list = []
        for i in range(0, num_of_grp_six_atom):
            if i == 0:
                start_col = 1
            else:
                start_col = end_col
            end_col = start_col+6
            single_grp_df = all_df.iloc[:, start_col:end_col]
            single_grp = self.muti_six_atm_lst[i]
            self.restrain_data_list.append(Restrain_Data(single_grp, single_grp_df, self.fraction))
        os.remove('tmp.csv')
        self.ori_restrain_data_list = self.restrain_data_list
        print(f'Number of the restraint group: {len(self.ori_restrain_data_list)}')

    def logout_specific_grp_data(self, grp_idx, logcsv_name):
        '''To log out the specific restraint group's data.

        Parameters
        ----------
        grp_idx: int 
            The index of the restraint group.(Starting from 0)
        logcsv_name: str
            The output name of csv_file, note that the csv_file's delimitor is '|'.
        '''
        self.ori_restrain_data_list[grp_idx].logout_ori_data(logcsv_name)

    def process_data(self, ):
        '''Do the Restrain_Data.data_init() and Restrain_Data.analyze() for every restrain_data in self.restrain_data_list.
        '''
        time_start_1 = timeit.default_timer()
        for restrain_data in self.restrain_data_list:
            restrain_data.data_init()
            restrain_data.analyze()
        time_end_1 = timeit.default_timer()
        print('Calculating the restraints energy and fitting the delta U distribution cost: '+str(time_end_1-time_start_1)+' seconds.')
        
    def sort_result(self, ):
        '''First remove the restrain_data in the self.restrain_data_list with restrain.ene greater than 3 kcal/mol (12.552 kJ/mol),
        then sort the restrain_data by the restrain.fopt.
        
        Generated or update properties
        ----------
        self.restrain_data_list: list
            A list contain many <class 'Restrain_Data'>, with the restrain.ene smaller than or equal to 3 kcal/mol (12.552 kJ/mol).
        self.sorted_res_list: list
            A list contain many <class 'Restrain_Data'>, sorted by the <class 'Restrain_Data'>.fopt. 
        '''
        self.restrain_data_list = [i for i in self.restrain_data_list if i.ene < 12.552]
        self.restrain_data_list = [i for i in self.restrain_data_list if i.dist_ary.mean()*10 < 10]
        if self.restrain_data_list == []:
            print('The candidate restraint scheme are not suitable to the large restraint energy!')
            sys.exit()
        else:
            pass
        self.sorted_res_list = sorted(self.restrain_data_list, key=lambda x:x.fopt)
        return self.sorted_res_list
    
    def get_best_result(self, ):
        '''Get the best result by getting the front 10 or <10 <class 'Restrain_Data'> first and then sort by restrain energy.
        
        Return
        ----------
        best_result: <class 'Restrain_Data'>
        '''
        self.res_list_4_std_sort = []
        if len(self.sorted_res_list) < 10:
            for i in range(len(self.sorted_res_list)):
                self.res_list_4_std_sort.append(self.sorted_res_list[i])
        else:
            for i in range(10):
                self.res_list_4_std_sort.append(self.sorted_res_list[i])
        self.res_list_4_std_sort = sorted(self.res_list_4_std_sort, key=lambda x:x.ene)
        best_result = self.res_list_4_std_sort[0]
        pd.DataFrame(best_result.statics_info, index=[0,]).to_csv('statics_info.csv')
        return best_result
    
    def generate_csv(self, csv_name, lst):
        '''To log the analysis result.
        '''
        #idx_lst = [i for i in range(0,len(lst))]
        column_lst = ['restraint_atom[lig1, lig2, lig3, rec1, rec2, rec3](start from 1)', 'rec_atoms[rec3, rec2, rec1](start from 0)', 'lig_atoms[lig1, lig2, lig3](start from 0)', 'distance between lig1 and rec1(unit: Angstrom)', 'angle between lig1 rec1 and rec2(unit:radian)','angle between lig2 lig1 and rec1(unit:radian)',\
        'dihedral between lig1 rec1 rec2 and rec3(unit:radian)', 'dihedral between lig2 lig1 rec1 and rec2(unit:radian)', 'dihedral between lig3 lig2 lig1 and rec1(unit:radian)', 'cal_ene(unit:kcal/mol)', 'cost function value']
 
        self.all_data = pd.concat([pd.DataFrame({'restraint_atom[lig1, lig2, lig3, rec1, rec2, rec3](start from 1)': [i.restrain_group,], 
                                            'rec_atoms[rec3, rec2, rec1](start from 0)': [[i.restrain_group[5]-1, i.restrain_group[4]-1, i.restrain_group[3]-1],],
                                            'lig_atoms[lig1, lig2, lig3](start from 0)': [[i.restrain_group[0]-1, i.restrain_group[1]-1, i.restrain_group[2]-1],],
                                            'distance between lig1 and rec1(unit: Angstrom)': [i.dist_ary.mean()*10],
                                            'angle between lig1 rec1 and rec2(unit:radian)': [i.ang1_ary.mean()],
                                            'angle between lig2 lig1 and rec1(unit:radian)': [i.ang2_ary.mean()],
                                            'dihedral between lig1 rec1 rec2 and rec3(unit:radian)': [i.cal_dihedral_mean(i.tor1_ary, 'radian', 'radian')],
                                            'dihedral between lig2 lig1 rec1 and rec2(unit:radian)': [i.cal_dihedral_mean(i.tor2_ary, 'radian', 'radian')], 
                                            'dihedral between lig3 lig2 lig1 and rec1(unit:radian)': [i.cal_dihedral_mean(i.tor3_ary, 'radian', 'radian')], 
                                            'cal_ene(unit:kcal/mol)': [i.ene/4.184],
                                            'cost function value': [i.fopt],    
                                            }, 
                                columns=column_lst,) 
                                for i in lst],ignore_index=True)
        #print(self.all_data)
        self.all_data.to_csv(csv_name,index=True)




class RestraintParam():
    def __init__(self, rec_atoms, lig_atoms, r, theta1, theta2, phi1, phi2, phi3, kbond=10, kangle=10, kdihedral=10):
        self.rec_atoms = rec_atoms # [rec3, rec2, rec1] started from 0
        self.lig_atoms = lig_atoms # [lig1, lig2, lig3] started from 0
        self.r = r # distance between rec1 and lig1, unit in Angstrom
        self.theta1 = theta1 # angle between rec2, rec1, lig1, unit in radians
        self.theta2 = theta2 # angle between rec1, lig1, lig2
        self.phi1 = phi1 # dihedral between rec3, rec2, rec1, lig1
        self.phi2 = phi2 # dihedral between rec2, rec1, lig1, lig2
        self.phi3 = phi3 # dihedral between rec1, lig1, lig2, lig3
        self.kbond = kbond # unit in kcal/mol/A^2
        self.kangle = kangle # unit in kcal/mol/rad^2
        self.kdihedral = kdihedral # unit in kcal/mol/rad^2
    def __repr__(self):
        return f'rec_atoms:{self.rec_atoms}, lig_atoms:{self.lig_atoms}, r:{self.r} A, theta1:{self.theta1} rad, theta2:{self.theta2} rad, phi1:{self.phi1} rad, phi2:{self.phi2} rad, phi3:{self.phi3} rad, kbond:{self.kbond} kcal/mol/A^2, kangle:{self.kangle} kcal/mol/rad^2, self.kdihedral:{self.kdihedral} kcal/mol/rad^2'
    def gen_measure_plumed(self, plumed_file_path, plumed_logout, output_frq):
        muti_six_atm_lst = [[self.lig_atoms[0]+1, self.lig_atoms[1]+1, self.lig_atoms[2]+1, self.rec_atoms[2]+1, self.rec_atoms[1]+1, self.rec_atoms[0]+1],]
        Plumed_gen_obj = Gen_plumed_input(muti_six_atm_lst)
        Plumed_gen_obj.gen_BoreschLike_measure(plumed_file_path, plumed_logout, output_frq)


if __name__ == '__main__':
    all_data_path = 'Colvar'
    muti_six_atm_lst = eval(open('./all_lst', 'r').read())
    res = ALL_Restrain_Data(all_data_path=all_data_path, muti_six_atm_lst=muti_six_atm_lst, fraction=0.75)
    res.process_data()
    res.generate_csv(csv_name="res_data_ori.csv", lst=res.restrain_data_list)
    res.generate_csv(csv_name="res_databyfopt.csv", lst=res.sort_result())

    lst_z = eval(open('./based_lig_shape', 'r').read())
    lst_a = eval(open('./based_HB_pair', 'r').read())
    lst_b = eval(open('./based_HB_mainchain', 'r').read())
    
    count = -1
    for i in res.sort_result():
        count+=1
        if count < 20:
            print('The serial number is {}.'.format(str(count+1)))
            if i.restrain_group in lst_z:
                print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by first strategy.')
                print('The cost function value is '+str(i.fopt))
            elif i.restrain_group in lst_a:
                print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by second strategy.')
                print('The cost function value is '+str(i.fopt))
            else:
                print('Six atoms used for restraints are :'+str(i.restrain_group)+ ', they are selected by third strategy.')
                print('The cost function value is '+str(i.fopt))
    best=res.get_best_result()

    res_parm = best.get_res_parm_4_openmm()
    
    np.savetxt('pre_w_f',best.delta_u) 
    res.generate_csv(csv_name="res_databystd.csv", lst=res.res_list_4_std_sort)
    best.draw_figure('best.png')
    with open('restr.txt', 'w') as restr_file:  
        restr_file.write(best.echo_rest_txt('openmm'))
